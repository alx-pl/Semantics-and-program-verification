<p dir="ltr" style="text-align: left;">In the case of "Big Steps" semantics, a non-terminal configuration is supposed to perform a single step directly to a final configuration.</p><p dir="ltr" style="text-align: left;">Today's exercises are meant to be done on whiteboard.</p><p dir="ltr" style="text-align: left;"></p><ol><li>Write a Big Steps semantics for Expr from Tiny. Note the necessary rules of the form (n, s) -&gt; n, which evaluate numbers to final configurations.</li><li>Try to add error handling, like "division by 0" or "unknown variable". Make sure that the semantics is deterministic (e.g. (1 / 0) + x, where x is not defined). Discuss symmetry breaking when enforcing the execution order on subterms.</li><li>Propose a Big Steps semantics for Tiny. Discuss the rule for while - try to make it compositional by using only sub-programs of the given program - do not rely on if-then-else.</li><li>Compare it to small-steps semantics in terms of involved proof sizes --- in small step semantics the proof sizes can be bounded by a function of the size of the program, while in big step semantics they depend also on initial state.</li><li>Discuss how to deal with break-continue, what is the life-cycle of the added flags?</li><li>Go back to Expr and add the construction "let - in".</li><li>What should we change if "let - in" was meant to be lazy? Remember the expression which has to be computed.</li><li>Discuss inductive construction of nested State and the existence of general Scott domains.</li><li>Notice that together with the expression, one has to remember the state in which it should be evaluated (give an example!).</li><li>Add the constructs (\ x . e) and (e_1 (e_2)) to Expr. Give an example of a correct expression where e_1 in application is NOT of the form (\ x . e).</li><li>Discuss their intended semantics. How to represent functions in configurations? (we take syntactic approach, not functional), so Fun = Var x Expr x State.</li><li>Write down the full big steps semantics of Expr with lambda abstaction and application.</li><li>Again ask what happens if we want to have lazy evaluation.</li><li>Express let-in in terms of the other constructs.</li></ol><p></p>
